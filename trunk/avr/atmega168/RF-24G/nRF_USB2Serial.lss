
nRF_USB2Serial.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000482  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000008  00800100  00800100  000004f6  2**0
                  ALLOC
  2 .debug_aranges 00000020  00000000  00000000  000004f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000f2  00000000  00000000  00000516  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000576  00000000  00000000  00000608  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000026a  00000000  00000000  00000b7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000007ca  00000000  00000000  00000de8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000000d0  00000000  00000000  000015b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000191  00000000  00000000  00001684  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000000e2  00000000  00000000  00001815  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000078  00000000  00000000  000018f7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   8:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 3d 01 	jmp	0x27a	; 0x27a <__vector_18>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d4 e0       	ldi	r29, 0x04	; 4
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	a8 30       	cpi	r26, 0x08	; 8
  80:	b1 07       	cpc	r27, r17
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 8d 01 	call	0x31a	; 0x31a <main>
  88:	0c 94 3f 02 	jmp	0x47e	; 0x47e <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <rx_data_nRF2401A>:
{
    uint8_t i, j, temp;
	
	temp = 0;
	
	cbi(PORTB, _01A_CE);//Power down RF Front end
  90:	29 98       	cbi	0x05, 1	; 5
  92:	e0 e0       	ldi	r30, 0x00	; 0
  94:	f1 e0       	ldi	r31, 0x01	; 1
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	0d c0       	rjmp	.+26     	; 0xb4 <rx_data_nRF2401A+0x24>
    //Clock in data, we are setup for 32-bit payloads
    for(i = 0 ; i < 4 ; i++) //4 bytes
    {
        for(j = 0 ; j < 8 ; j++) //8 bits each
        {
            temp <<= 1;
  9a:	99 0f       	add	r25, r25
			if(PIND & (1<<_01A_DATA)) temp |= 1;
  9c:	4f 99       	sbic	0x09, 7	; 9
  9e:	91 60       	ori	r25, 0x01	; 1

			sbi(PORTB, _01A_CLK);
  a0:	2d 9a       	sbi	0x05, 5	; 5

			cbi(PORTB, _01A_CLK);
  a2:	2d 98       	cbi	0x05, 5	; 5
	cbi(PORTB, _01A_CE);//Power down RF Front end

    //Clock in data, we are setup for 32-bit payloads
    for(i = 0 ; i < 4 ; i++) //4 bytes
    {
        for(j = 0 ; j < 8 ; j++) //8 bits each
  a4:	8f 5f       	subi	r24, 0xFF	; 255
  a6:	88 30       	cpi	r24, 0x08	; 8
  a8:	c1 f7       	brne	.-16     	; 0x9a <rx_data_nRF2401A+0xa>
			sbi(PORTB, _01A_CLK);

			cbi(PORTB, _01A_CLK);
        }

        rf_rx_array[i] = temp; //Store this byte
  aa:	91 93       	st	Z+, r25
	temp = 0;
	
	cbi(PORTB, _01A_CE);//Power down RF Front end

    //Clock in data, we are setup for 32-bit payloads
    for(i = 0 ; i < 4 ; i++) //4 bytes
  ac:	81 e0       	ldi	r24, 0x01	; 1
  ae:	e4 30       	cpi	r30, 0x04	; 4
  b0:	f8 07       	cpc	r31, r24
  b2:	11 f0       	breq	.+4      	; 0xb8 <rx_data_nRF2401A+0x28>
  b4:	80 e0       	ldi	r24, 0x00	; 0
  b6:	f1 cf       	rjmp	.-30     	; 0x9a <rx_data_nRF2401A+0xa>
        }

        rf_rx_array[i] = temp; //Store this byte
    }

    sbi(PORTB, _01A_CE); //Power up RF Front end
  b8:	29 9a       	sbi	0x05, 1	; 5
}
  ba:	08 95       	ret

000000bc <tx_data_nRF2401A>:
//data_array must be setup before calling this function
void tx_data_nRF2401A(void)
{
    uint8_t i, j, temp, rf_address;

    sbi(PORTB, _01A_CE); //_01A_CE = 1;
  bc:	29 9a       	sbi	0x05, 1	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
  be:	81 e0       	ldi	r24, 0x01	; 1
  c0:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
  c2:	8e ec       	ldi	r24, 0xCE	; 206
  c4:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
  c8:	b8 9b       	sbis	0x17, 0	; 23
  ca:	fe cf       	rjmp	.-4      	; 0xc8 <tx_data_nRF2401A+0xc>
  cc:	20 e0       	ldi	r18, 0x00	; 0
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
  ce:	41 e0       	ldi	r20, 0x01	; 1
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
  d0:	3e ec       	ldi	r19, 0xCE	; 206
  d2:	13 c0       	rjmp	.+38     	; 0xfa <tx_data_nRF2401A+0x3e>
	
			sbi(PORTB, _01A_CLK); //_01A_CLK = 1; 
			delay_us(RF_DELAY);
			cbi(PORTB, _01A_CLK); //_01A_CLK = 0;
			
			rf_address <<= 1;
  d4:	88 0f       	add	r24, r24
	{
		rf_address = 0b11100111; //Power-on Default for all units (on page 11)
	
		for(i = 0 ; i < 8 ; i++)
		{
			if(rf_address & 0x80)
  d6:	87 ff       	sbrs	r24, 7
  d8:	02 c0       	rjmp	.+4      	; 0xde <tx_data_nRF2401A+0x22>
				sbi(PORTD, _01A_DATA);
  da:	5f 9a       	sbi	0x0b, 7	; 11
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <tx_data_nRF2401A+0x24>
			else
				cbi(PORTD, _01A_DATA);
  de:	5f 98       	cbi	0x0b, 7	; 11
	
			sbi(PORTB, _01A_CLK); //_01A_CLK = 1; 
  e0:	2d 9a       	sbi	0x05, 5	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
  e2:	47 bb       	out	0x17, r20	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
  e4:	30 93 b2 00 	sts	0x00B2, r19
	while( (TIFR2 & (1<<TOV2)) == 0);
  e8:	b8 9b       	sbis	0x17, 0	; 23
  ea:	fe cf       	rjmp	.-4      	; 0xe8 <tx_data_nRF2401A+0x2c>
			delay_us(RF_DELAY);
			cbi(PORTB, _01A_CLK); //_01A_CLK = 0;
  ec:	2d 98       	cbi	0x05, 5	; 5
    //Clock in address
	for (j = 0; j < 5; j++)
	{
		rf_address = 0b11100111; //Power-on Default for all units (on page 11)
	
		for(i = 0 ; i < 8 ; i++)
  ee:	9f 5f       	subi	r25, 0xFF	; 255
  f0:	98 30       	cpi	r25, 0x08	; 8
  f2:	81 f7       	brne	.-32     	; 0xd4 <tx_data_nRF2401A+0x18>

    sbi(PORTB, _01A_CE); //_01A_CE = 1;
    delay_us(RF_DELAY);

    //Clock in address
	for (j = 0; j < 5; j++)
  f4:	2f 5f       	subi	r18, 0xFF	; 255
  f6:	25 30       	cpi	r18, 0x05	; 5
  f8:	19 f0       	breq	.+6      	; 0x100 <tx_data_nRF2401A+0x44>
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	87 ee       	ldi	r24, 0xE7	; 231
  fe:	eb cf       	rjmp	.-42     	; 0xd6 <tx_data_nRF2401A+0x1a>
 100:	e4 e0       	ldi	r30, 0x04	; 4
 102:	f1 e0       	ldi	r31, 0x01	; 1
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 104:	31 e0       	ldi	r19, 0x01	; 1
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 106:	2e ec       	ldi	r18, 0xCE	; 206
	}	
    
    //Clock in the data_array
    for(i = 0 ; i < 4 ; i++) //4 bytes
    {
        temp = rf_tx_array[i];
 108:	90 81       	ld	r25, Z
 10a:	80 e0       	ldi	r24, 0x00	; 0
        
        for(j = 0 ; j < 8 ; j++) //One bit at a time
        {
			if(temp & 0x80)
 10c:	97 ff       	sbrs	r25, 7
 10e:	02 c0       	rjmp	.+4      	; 0x114 <tx_data_nRF2401A+0x58>
				sbi(PORTD, _01A_DATA);
 110:	5f 9a       	sbi	0x0b, 7	; 11
 112:	01 c0       	rjmp	.+2      	; 0x116 <tx_data_nRF2401A+0x5a>
			else
				cbi(PORTD, _01A_DATA);
 114:	5f 98       	cbi	0x0b, 7	; 11
			
			sbi(PORTB, _01A_CLK); //_01A_CLK = 1; 
 116:	2d 9a       	sbi	0x05, 5	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 118:	37 bb       	out	0x17, r19	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 11a:	20 93 b2 00 	sts	0x00B2, r18
	while( (TIFR2 & (1<<TOV2)) == 0);
 11e:	b8 9b       	sbis	0x17, 0	; 23
 120:	fe cf       	rjmp	.-4      	; 0x11e <tx_data_nRF2401A+0x62>
			delay_us(RF_DELAY);
			cbi(PORTB, _01A_CLK); //_01A_CLK = 0;
 122:	2d 98       	cbi	0x05, 5	; 5
    //Clock in the data_array
    for(i = 0 ; i < 4 ; i++) //4 bytes
    {
        temp = rf_tx_array[i];
        
        for(j = 0 ; j < 8 ; j++) //One bit at a time
 124:	8f 5f       	subi	r24, 0xFF	; 255
 126:	88 30       	cpi	r24, 0x08	; 8
 128:	11 f0       	breq	.+4      	; 0x12e <tx_data_nRF2401A+0x72>
			
			sbi(PORTB, _01A_CLK); //_01A_CLK = 1; 
			delay_us(RF_DELAY);
			cbi(PORTB, _01A_CLK); //_01A_CLK = 0;
	
            temp <<= 1;
 12a:	99 0f       	add	r25, r25
 12c:	ef cf       	rjmp	.-34     	; 0x10c <tx_data_nRF2401A+0x50>
 12e:	31 96       	adiw	r30, 0x01	; 1
			rf_address <<= 1;
		}
	}	
    
    //Clock in the data_array
    for(i = 0 ; i < 4 ; i++) //4 bytes
 130:	81 e0       	ldi	r24, 0x01	; 1
 132:	e8 30       	cpi	r30, 0x08	; 8
 134:	f8 07       	cpc	r31, r24
 136:	41 f7       	brne	.-48     	; 0x108 <tx_data_nRF2401A+0x4c>
	
            temp <<= 1;
        }
    }
    
	cbi(PORTB, _01A_CE); //_01A_CE = 0; //Start transmission   
 138:	29 98       	cbi	0x05, 1	; 5
}
 13a:	08 95       	ret

0000013c <config_rx_nRF2401A>:
    uint8_t i, j;
    uint32_t config_setup;

    //During configuration of the receiver, we need _01A_DATA as an output
    //1 = output, 0 = input
    _01A_PORT_DD |= (1<<_01A_DATA);  //(_01A_DR is input) (_01A_DATA is output)
 13c:	57 9a       	sbi	0x0a, 7	; 10

    //Config Mode
    cbi(PORTB, _01A_CE); //_01A_CE = 0; _01A_CS = 1;
 13e:	29 98       	cbi	0x05, 1	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 140:	81 e0       	ldi	r24, 0x01	; 1
 142:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 144:	8e ec       	ldi	r24, 0xCE	; 206
 146:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 14a:	b8 9b       	sbis	0x17, 0	; 23
 14c:	fe cf       	rjmp	.-4      	; 0x14a <config_rx_nRF2401A+0xe>
    delay_us(RF_DELAY);
	sbi(PORTB, _01A_CS);
 14e:	2a 9a       	sbi	0x05, 2	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 150:	81 e0       	ldi	r24, 0x01	; 1
 152:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 154:	8e ec       	ldi	r24, 0xCE	; 206
 156:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 15a:	b8 9b       	sbis	0x17, 0	; 23
 15c:	fe cf       	rjmp	.-4      	; 0x15a <config_rx_nRF2401A+0x1e>
 15e:	30 e0       	ldi	r19, 0x00	; 0
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 160:	51 e0       	ldi	r21, 0x01	; 1
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 162:	4e ec       	ldi	r20, 0xCE	; 206
 164:	16 c0       	rjmp	.+44     	; 0x192 <config_rx_nRF2401A+0x56>

			sbi(PORTB, _01A_CLK);
			delay_us(RF_DELAY);
			cbi(PORTB, _01A_CLK);
			
			config_setup <<= 1;
 166:	88 0f       	add	r24, r24
 168:	99 1f       	adc	r25, r25
 16a:	aa 1f       	adc	r26, r26
 16c:	bb 1f       	adc	r27, r27
	{
		config_setup = 0xE7;

		for(i = 0 ; i < 8 ; i++)
		{
			if(config_setup & 0x80)
 16e:	87 ff       	sbrs	r24, 7
 170:	02 c0       	rjmp	.+4      	; 0x176 <config_rx_nRF2401A+0x3a>
				sbi(_01A_PORT, _01A_DATA);
 172:	5f 9a       	sbi	0x0b, 7	; 11
 174:	01 c0       	rjmp	.+2      	; 0x178 <config_rx_nRF2401A+0x3c>
			else
				cbi(_01A_PORT, _01A_DATA);
 176:	5f 98       	cbi	0x0b, 7	; 11

			sbi(PORTB, _01A_CLK);
 178:	2d 9a       	sbi	0x05, 5	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 17a:	57 bb       	out	0x17, r21	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 17c:	40 93 b2 00 	sts	0x00B2, r20
	while( (TIFR2 & (1<<TOV2)) == 0);
 180:	b8 9b       	sbis	0x17, 0	; 23
 182:	fe cf       	rjmp	.-4      	; 0x180 <config_rx_nRF2401A+0x44>
			delay_us(RF_DELAY);
			cbi(PORTB, _01A_CLK);
 184:	2d 98       	cbi	0x05, 5	; 5
	//Channel 1 40-bit (5-byte) address setup
    for(j = 0 ; j < 5 ; j++)
	{
		config_setup = 0xE7;

		for(i = 0 ; i < 8 ; i++)
 186:	2f 5f       	subi	r18, 0xFF	; 255
 188:	28 30       	cpi	r18, 0x08	; 8
 18a:	69 f7       	brne	.-38     	; 0x166 <config_rx_nRF2401A+0x2a>
    //Delay of 5us from CS to Data (page 30) is taken care of by the for loop
    delay_us(RF_DELAY);
	
    //Setup configuration bank	
	//Channel 1 40-bit (5-byte) address setup
    for(j = 0 ; j < 5 ; j++)
 18c:	3f 5f       	subi	r19, 0xFF	; 255
 18e:	35 30       	cpi	r19, 0x05	; 5
 190:	31 f0       	breq	.+12     	; 0x19e <config_rx_nRF2401A+0x62>
 192:	20 e0       	ldi	r18, 0x00	; 0
 194:	87 ee       	ldi	r24, 0xE7	; 231
 196:	90 e0       	ldi	r25, 0x00	; 0
 198:	a0 e0       	ldi	r26, 0x00	; 0
 19a:	b0 e0       	ldi	r27, 0x00	; 0
 19c:	e8 cf       	rjmp	.-48     	; 0x16e <config_rx_nRF2401A+0x32>
 19e:	20 e0       	ldi	r18, 0x00	; 0
 1a0:	85 e0       	ldi	r24, 0x05	; 5
 1a2:	9e e6       	ldi	r25, 0x6E	; 110
 1a4:	a3 ea       	ldi	r26, 0xA3	; 163
 1a6:	b0 e0       	ldi	r27, 0x00	; 0
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 1a8:	41 e0       	ldi	r20, 0x01	; 1
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 1aa:	3e ec       	ldi	r19, 0xCE	; 206
	//config_setup = 0x00A36E05; //0b.1010.0011. 0110.1110. 0000.0101; 
	config_setup = 0xA36E05;

    for(i = 0 ; i < 24 ; i++)
    {
		if(config_setup & 0x00800000)
 1ac:	a7 ff       	sbrs	r26, 7
 1ae:	02 c0       	rjmp	.+4      	; 0x1b4 <config_rx_nRF2401A+0x78>
			sbi(_01A_PORT, _01A_DATA);
 1b0:	5f 9a       	sbi	0x0b, 7	; 11
 1b2:	01 c0       	rjmp	.+2      	; 0x1b6 <config_rx_nRF2401A+0x7a>
		else
			cbi(_01A_PORT, _01A_DATA);
 1b4:	5f 98       	cbi	0x0b, 7	; 11

		sbi(PORTB, _01A_CLK);
 1b6:	2d 9a       	sbi	0x05, 5	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 1b8:	47 bb       	out	0x17, r20	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 1ba:	30 93 b2 00 	sts	0x00B2, r19
	while( (TIFR2 & (1<<TOV2)) == 0);
 1be:	b8 9b       	sbis	0x17, 0	; 23
 1c0:	fe cf       	rjmp	.-4      	; 0x1be <config_rx_nRF2401A+0x82>
		delay_us(RF_DELAY);
		cbi(PORTB, _01A_CLK);
 1c2:	2d 98       	cbi	0x05, 5	; 5
	//Lower 24 bit setup
    //Set last bit for receive mode
	//config_setup = 0x00A36E05; //0b.1010.0011. 0110.1110. 0000.0101; 
	config_setup = 0xA36E05;

    for(i = 0 ; i < 24 ; i++)
 1c4:	2f 5f       	subi	r18, 0xFF	; 255
 1c6:	28 31       	cpi	r18, 0x18	; 24
 1c8:	29 f0       	breq	.+10     	; 0x1d4 <config_rx_nRF2401A+0x98>

		sbi(PORTB, _01A_CLK);
		delay_us(RF_DELAY);
		cbi(PORTB, _01A_CLK);
        
        config_setup <<= 1;
 1ca:	88 0f       	add	r24, r24
 1cc:	99 1f       	adc	r25, r25
 1ce:	aa 1f       	adc	r26, r26
 1d0:	bb 1f       	adc	r27, r27
 1d2:	ec cf       	rjmp	.-40     	; 0x1ac <config_rx_nRF2401A+0x70>
    }
    
    //Configuration is actived on falling edge of CS (page 10)
    cbi(PORTB, _01A_CE); //_01A_CE = 0; _01A_CS = 0;
 1d4:	29 98       	cbi	0x05, 1	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 1d6:	81 e0       	ldi	r24, 0x01	; 1
 1d8:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 1da:	8e ec       	ldi	r24, 0xCE	; 206
 1dc:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 1e0:	b8 9b       	sbis	0x17, 0	; 23
 1e2:	fe cf       	rjmp	.-4      	; 0x1e0 <config_rx_nRF2401A+0xa4>
    delay_us(RF_DELAY);
	cbi(PORTB, _01A_CS);
 1e4:	2a 98       	cbi	0x05, 2	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 1e6:	81 e0       	ldi	r24, 0x01	; 1
 1e8:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 1ea:	8e ec       	ldi	r24, 0xCE	; 206
 1ec:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 1f0:	b8 9b       	sbis	0x17, 0	; 23
 1f2:	fe cf       	rjmp	.-4      	; 0x1f0 <config_rx_nRF2401A+0xb4>
    delay_us(RF_DELAY);
    
    //After configuration of the receiver, we need _01A_DATA as an input
    //1 = output, 0 = input
    _01A_PORT_DD &= ~((1<<_01A_DR)|(1<<_01A_DATA));  //(_01A_DR is input) (_01A_DATA is input)
 1f4:	8a b1       	in	r24, 0x0a	; 10
 1f6:	8f 73       	andi	r24, 0x3F	; 63
 1f8:	8a b9       	out	0x0a, r24	; 10

    //Start monitoring the air
    sbi(PORTB, _01A_CE); //_01A_CE = 1; _01A_CS = 0;
 1fa:	29 9a       	sbi	0x05, 1	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 1fc:	81 e0       	ldi	r24, 0x01	; 1
 1fe:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 200:	8e ec       	ldi	r24, 0xCE	; 206
 202:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 206:	b8 9b       	sbis	0x17, 0	; 23
 208:	fe cf       	rjmp	.-4      	; 0x206 <config_rx_nRF2401A+0xca>
    delay_us(RF_DELAY);
	cbi(PORTB, _01A_CS);
 20a:	2a 98       	cbi	0x05, 2	; 5
}    
 20c:	08 95       	ret

0000020e <config_tx_nRF2401A>:
void config_tx_nRF2401A(void)
{
    uint8_t i;
    uint32_t config_setup;
	
	_01A_PORT_DD |= (1<<_01A_DATA);
 20e:	57 9a       	sbi	0x0a, 7	; 10

    //Config Mode
    cbi(PORTB, _01A_CE); //_01A_CE = 0; 
 210:	29 98       	cbi	0x05, 1	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 212:	81 e0       	ldi	r24, 0x01	; 1
 214:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 216:	8e ec       	ldi	r24, 0xCE	; 206
 218:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 21c:	b8 9b       	sbis	0x17, 0	; 23
 21e:	fe cf       	rjmp	.-4      	; 0x21c <config_tx_nRF2401A+0xe>
    delay_us(RF_DELAY);
	sbi(PORTB, _01A_CS); //_01A_CS = 1;
 220:	2a 9a       	sbi	0x05, 2	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 222:	81 e0       	ldi	r24, 0x01	; 1
 224:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 226:	8e ec       	ldi	r24, 0xCE	; 206
 228:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 22c:	b8 9b       	sbis	0x17, 0	; 23
 22e:	fe cf       	rjmp	.-4      	; 0x22c <config_tx_nRF2401A+0x1e>
 230:	20 e0       	ldi	r18, 0x00	; 0
 232:	84 e0       	ldi	r24, 0x04	; 4
 234:	9e e6       	ldi	r25, 0x6E	; 110
 236:	a3 ea       	ldi	r26, 0xA3	; 163
 238:	b0 e0       	ldi	r27, 0x00	; 0
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 23a:	41 e0       	ldi	r20, 0x01	; 1
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 23c:	3e ec       	ldi	r19, 0xCE	; 206
    //Setup configuration word
    //config_setup = 0x00A36E04; //0b.0010.0011.0110.1110.0000.0100; //Look at pages 13-15 for more bit info

    for(i = 0 ; i < 24 ; i++)
    {
		if(config_setup & 0x00800000)
 23e:	a7 ff       	sbrs	r26, 7
 240:	02 c0       	rjmp	.+4      	; 0x246 <config_tx_nRF2401A+0x38>
			sbi(_01A_PORT, _01A_DATA);
 242:	5f 9a       	sbi	0x0b, 7	; 11
 244:	01 c0       	rjmp	.+2      	; 0x248 <config_tx_nRF2401A+0x3a>
		else
			cbi(_01A_PORT, _01A_DATA);
 246:	5f 98       	cbi	0x0b, 7	; 11
		
		sbi(PORTB, _01A_CLK); //_01A_CLK = 1;
 248:	2d 9a       	sbi	0x05, 5	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 24a:	47 bb       	out	0x17, r20	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 24c:	30 93 b2 00 	sts	0x00B2, r19
	while( (TIFR2 & (1<<TOV2)) == 0);
 250:	b8 9b       	sbis	0x17, 0	; 23
 252:	fe cf       	rjmp	.-4      	; 0x250 <config_tx_nRF2401A+0x42>
		delay_us(RF_DELAY);
		cbi(PORTB, _01A_CLK); //_01A_CLK = 0; 
 254:	2d 98       	cbi	0x05, 5	; 5
	
	config_setup = 0xA36E04;
    //Setup configuration word
    //config_setup = 0x00A36E04; //0b.0010.0011.0110.1110.0000.0100; //Look at pages 13-15 for more bit info

    for(i = 0 ; i < 24 ; i++)
 256:	2f 5f       	subi	r18, 0xFF	; 255
 258:	28 31       	cpi	r18, 0x18	; 24
 25a:	29 f0       	breq	.+10     	; 0x266 <config_tx_nRF2401A+0x58>
		
		sbi(PORTB, _01A_CLK); //_01A_CLK = 1;
		delay_us(RF_DELAY);
		cbi(PORTB, _01A_CLK); //_01A_CLK = 0; 

        config_setup <<= 1;
 25c:	88 0f       	add	r24, r24
 25e:	99 1f       	adc	r25, r25
 260:	aa 1f       	adc	r26, r26
 262:	bb 1f       	adc	r27, r27
 264:	ec cf       	rjmp	.-40     	; 0x23e <config_tx_nRF2401A+0x30>
    }
    
    //Configuration is actived on falling edge of CS (page 10)
    cbi(PORTB, _01A_CE); //_01A_CE = 0; 
 266:	29 98       	cbi	0x05, 1	; 5
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 268:	81 e0       	ldi	r24, 0x01	; 1
 26a:	87 bb       	out	0x17, r24	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 26c:	8e ec       	ldi	r24, 0xCE	; 206
 26e:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 272:	b8 9b       	sbis	0x17, 0	; 23
 274:	fe cf       	rjmp	.-4      	; 0x272 <config_tx_nRF2401A+0x64>
    delay_us(RF_DELAY);
	cbi(PORTB, _01A_CS); //_01A_CS = 0;
 276:	2a 98       	cbi	0x05, 2	; 5
}
 278:	08 95       	ret

0000027a <__vector_18>:
//======================



ISR (SIG_USART_RECV)//USART Receive Interrupt
{
 27a:	1f 92       	push	r1
 27c:	0f 92       	push	r0
 27e:	0f b6       	in	r0, 0x3f	; 63
 280:	0f 92       	push	r0
 282:	11 24       	eor	r1, r1
 284:	2f 93       	push	r18
 286:	3f 93       	push	r19
 288:	4f 93       	push	r20
 28a:	5f 93       	push	r21
 28c:	6f 93       	push	r22
 28e:	7f 93       	push	r23
 290:	8f 93       	push	r24
 292:	9f 93       	push	r25
 294:	af 93       	push	r26
 296:	bf 93       	push	r27
 298:	ef 93       	push	r30
 29a:	ff 93       	push	r31
	cli();//Disable Interrupts
 29c:	f8 94       	cli
	
	rf_tx_array[1] = rf_tx_array[2] = UDR0;
 29e:	80 91 c6 00 	lds	r24, 0x00C6
 2a2:	80 93 06 01 	sts	0x0106, r24
 2a6:	80 93 05 01 	sts	0x0105, r24
	
	config_tx_nRF2401A();
 2aa:	0e 94 07 01 	call	0x20e	; 0x20e <config_tx_nRF2401A>
	tx_data_nRF2401A();
 2ae:	0e 94 5e 00 	call	0xbc	; 0xbc <tx_data_nRF2401A>
	config_rx_nRF2401A();
 2b2:	0e 94 9e 00 	call	0x13c	; 0x13c <config_rx_nRF2401A>
	
	sei();//Enable Interrupts
 2b6:	78 94       	sei
	
}
 2b8:	ff 91       	pop	r31
 2ba:	ef 91       	pop	r30
 2bc:	bf 91       	pop	r27
 2be:	af 91       	pop	r26
 2c0:	9f 91       	pop	r25
 2c2:	8f 91       	pop	r24
 2c4:	7f 91       	pop	r23
 2c6:	6f 91       	pop	r22
 2c8:	5f 91       	pop	r21
 2ca:	4f 91       	pop	r20
 2cc:	3f 91       	pop	r19
 2ce:	2f 91       	pop	r18
 2d0:	0f 90       	pop	r0
 2d2:	0f be       	out	0x3f, r0	; 63
 2d4:	0f 90       	pop	r0
 2d6:	1f 90       	pop	r1
 2d8:	18 95       	reti

000002da <initPWM>:

void initPWM(){
   DDRB |= 0b00001000 ;   //set PB1, PB2 and PB3 as outputs
 2da:	23 9a       	sbi	0x04, 3	; 4
   LED = 0;   //PWMs set to zero
 2dc:	10 92 b3 00 	sts	0x00B3, r1
   //timer 2 - 8 bit Fast PWM - no pre-scaler - non-inverting
   TCCR2A = (1 << WGM21) | (1<<WGM20) | (1 << COM2A1) | (0 << COM2A0);
 2e0:	83 e8       	ldi	r24, 0x83	; 131
 2e2:	80 93 b0 00 	sts	0x00B0, r24
   TCCR2B = (0 << CS22) | (0 << CS21) | (1 << CS20);
 2e6:	81 e0       	ldi	r24, 0x01	; 1
 2e8:	80 93 b1 00 	sts	0x00B1, r24
}
 2ec:	08 95       	ret

000002ee <ioinit>:


void ioinit(void)
{
	//1 = output, 0 = input
	DDRC = 0b00000111;//Status LEDs on PC0-2
 2ee:	97 e0       	ldi	r25, 0x07	; 7
 2f0:	97 b9       	out	0x07, r25	; 7
	DDRB = 0b00100110;
 2f2:	86 e2       	ldi	r24, 0x26	; 38
 2f4:	84 b9       	out	0x04, r24	; 4
	
	PORTC = 0b00000111;
 2f6:	98 b9       	out	0x08, r25	; 8

	//1 = output, 0 = input
	DDRD |= 0b00000010;  //(TXD on PD1)
 2f8:	51 9a       	sbi	0x0a, 1	; 10
	DDRD &= ~(0b00000001);  //(RXD on PD0)
 2fa:	50 98       	cbi	0x0a, 0	; 10

	//USART Baud rate: 9600
	UBRR0H = (8<<MYUBRR);
 2fc:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = MYUBRR;
 300:	87 e6       	ldi	r24, 0x67	; 103
 302:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0);
 306:	88 e9       	ldi	r24, 0x98	; 152
 308:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = (1<<USBS0)|(3<<UCSZ00);
 30c:	8e e0       	ldi	r24, 0x0E	; 14
 30e:	80 93 c2 00 	sts	0x00C2, r24

	//Init Timer0 for delay_us
	//TCCR0B = (1<<CS00); //Set Prescaler to No Prescaling (assume we are running at internal 1MHz). CS00=1 
	TCCR2B = (1<<CS20); //Set Prescaler to 1. CS20=1
 312:	81 e0       	ldi	r24, 0x01	; 1
 314:	80 93 b1 00 	sts	0x00B1, r24
}
 318:	08 95       	ret

0000031a <main>:

   return 0;
}

int main(void)
{
 31a:	af 92       	push	r10
 31c:	bf 92       	push	r11
 31e:	cf 92       	push	r12
 320:	df 92       	push	r13
 322:	ef 92       	push	r14
 324:	ff 92       	push	r15
 326:	0f 93       	push	r16
 328:	1f 93       	push	r17
	int x=0;
	
	LED = 0;
 32a:	10 92 b3 00 	sts	0x00B3, r1
	
	ioinit();
 32e:	0e 94 77 01 	call	0x2ee	; 0x2ee <ioinit>
	sei();//Enable Interrupts
	
}

void initPWM(){
   DDRB |= 0b00001000 ;   //set PB1, PB2 and PB3 as outputs
 332:	23 9a       	sbi	0x04, 3	; 4
   LED = 0;   //PWMs set to zero
 334:	10 92 b3 00 	sts	0x00B3, r1
   //timer 2 - 8 bit Fast PWM - no pre-scaler - non-inverting
   TCCR2A = (1 << WGM21) | (1<<WGM20) | (1 << COM2A1) | (0 << COM2A0);
 338:	83 e8       	ldi	r24, 0x83	; 131
 33a:	80 93 b0 00 	sts	0x00B0, r24
   TCCR2B = (0 << CS22) | (0 << CS21) | (1 << CS20);
 33e:	81 e0       	ldi	r24, 0x01	; 1
 340:	80 93 b1 00 	sts	0x00B1, r24
	ioinit();
	initPWM();

	for (x = 0; x < 4; x++)
	{
		rf_rx_array[x] = 0;
 344:	10 92 00 01 	sts	0x0100, r1
 348:	10 92 01 01 	sts	0x0101, r1
 34c:	10 92 02 01 	sts	0x0102, r1
 350:	10 92 03 01 	sts	0x0103, r1
	}
	
	rf_tx_array[0] = 59; // ;
 354:	8b e3       	ldi	r24, 0x3B	; 59
 356:	80 93 04 01 	sts	0x0104, r24
	rf_tx_array[3] = 42; // *
 35a:	8a e2       	ldi	r24, 0x2A	; 42
 35c:	80 93 07 01 	sts	0x0107, r24
	
	config_rx_nRF2401A();
 360:	0e 94 9e 00 	call	0x13c	; 0x13c <config_rx_nRF2401A>
	
	sei();
 364:	78 94       	sei
			if(rf_rx_array[1] == 51) LED = 8;//3
			if(rf_rx_array[1] == 52) LED = 16;//4
			if(rf_rx_array[1] == 53) LED = 32;//5
			if(rf_rx_array[1] == 54) LED = 64;//6
			if(rf_rx_array[1] == 55) LED = 128;//7
			if(rf_rx_array[1] == 56) LED = 255;//8
 366:	aa 24       	eor	r10, r10
 368:	aa 94       	dec	r10
			if(rf_rx_array[1] == 50) LED = 4;//2
			if(rf_rx_array[1] == 51) LED = 8;//3
			if(rf_rx_array[1] == 52) LED = 16;//4
			if(rf_rx_array[1] == 53) LED = 32;//5
			if(rf_rx_array[1] == 54) LED = 64;//6
			if(rf_rx_array[1] == 55) LED = 128;//7
 36a:	10 e8       	ldi	r17, 0x80	; 128
 36c:	b1 2e       	mov	r11, r17
			if(rf_rx_array[1] == 49) LED = 2;//1
			if(rf_rx_array[1] == 50) LED = 4;//2
			if(rf_rx_array[1] == 51) LED = 8;//3
			if(rf_rx_array[1] == 52) LED = 16;//4
			if(rf_rx_array[1] == 53) LED = 32;//5
			if(rf_rx_array[1] == 54) LED = 64;//6
 36e:	b0 e4       	ldi	r27, 0x40	; 64
 370:	cb 2e       	mov	r12, r27
			if(rf_rx_array[1] == 48) LED = 0;//0
			if(rf_rx_array[1] == 49) LED = 2;//1
			if(rf_rx_array[1] == 50) LED = 4;//2
			if(rf_rx_array[1] == 51) LED = 8;//3
			if(rf_rx_array[1] == 52) LED = 16;//4
			if(rf_rx_array[1] == 53) LED = 32;//5
 372:	a0 e2       	ldi	r26, 0x20	; 32
 374:	da 2e       	mov	r13, r26
		if(rf_rx_array[1] >= 48 && rf_rx_array[1] <= 56){
			if(rf_rx_array[1] == 48) LED = 0;//0
			if(rf_rx_array[1] == 49) LED = 2;//1
			if(rf_rx_array[1] == 50) LED = 4;//2
			if(rf_rx_array[1] == 51) LED = 8;//3
			if(rf_rx_array[1] == 52) LED = 16;//4
 376:	f0 e1       	ldi	r31, 0x10	; 16
 378:	ef 2e       	mov	r14, r31
		
		if(rf_rx_array[1] >= 48 && rf_rx_array[1] <= 56){
			if(rf_rx_array[1] == 48) LED = 0;//0
			if(rf_rx_array[1] == 49) LED = 2;//1
			if(rf_rx_array[1] == 50) LED = 4;//2
			if(rf_rx_array[1] == 51) LED = 8;//3
 37a:	e8 e0       	ldi	r30, 0x08	; 8
 37c:	fe 2e       	mov	r15, r30
		}
		
		if(rf_rx_array[1] >= 48 && rf_rx_array[1] <= 56){
			if(rf_rx_array[1] == 48) LED = 0;//0
			if(rf_rx_array[1] == 49) LED = 2;//1
			if(rf_rx_array[1] == 50) LED = 4;//2
 37e:	04 e0       	ldi	r16, 0x04	; 4
			}
		}
		
		if(rf_rx_array[1] >= 48 && rf_rx_array[1] <= 56){
			if(rf_rx_array[1] == 48) LED = 0;//0
			if(rf_rx_array[1] == 49) LED = 2;//1
 380:	12 e0       	ldi	r17, 0x02	; 2
	
	sei();
	
	for(;;)
	{	
		if (_01A_PORT_PIN & (1<<_01A_DR))
 382:	4e 9b       	sbis	0x09, 6	; 9
 384:	16 c0       	rjmp	.+44     	; 0x3b2 <main+0x98>
		{
			rx_data_nRF2401A();
 386:	0e 94 48 00 	call	0x90	; 0x90 <rx_data_nRF2401A>
			
			if (rf_rx_array[0] == 59 && rf_rx_array[1] == rf_rx_array[2] && rf_rx_array[3] == 42)
 38a:	80 91 00 01 	lds	r24, 0x0100
 38e:	8b 33       	cpi	r24, 0x3B	; 59
 390:	81 f4       	brne	.+32     	; 0x3b2 <main+0x98>
 392:	90 91 01 01 	lds	r25, 0x0101
 396:	80 91 02 01 	lds	r24, 0x0102
 39a:	98 17       	cp	r25, r24
 39c:	51 f4       	brne	.+20     	; 0x3b2 <main+0x98>
 39e:	80 91 03 01 	lds	r24, 0x0103
 3a2:	8a 32       	cpi	r24, 0x2A	; 42
 3a4:	31 f4       	brne	.+12     	; 0x3b2 <main+0x98>


void put_char(char byte)
{
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) );
 3a6:	80 91 c0 00 	lds	r24, 0x00C0
 3aa:	85 ff       	sbrs	r24, 5
 3ac:	fc cf       	rjmp	.-8      	; 0x3a6 <main+0x8c>
	/* Put data into buffer, sends the data */
	UDR0 = byte;
 3ae:	90 93 c6 00 	sts	0x00C6, r25
			{
				put_char(rf_rx_array[1]);
			}
		}
		
		if(rf_rx_array[1] >= 48 && rf_rx_array[1] <= 56){
 3b2:	90 91 01 01 	lds	r25, 0x0101
 3b6:	89 2f       	mov	r24, r25
 3b8:	80 53       	subi	r24, 0x30	; 48
 3ba:	89 30       	cpi	r24, 0x09	; 9
 3bc:	10 f7       	brcc	.-60     	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 48) LED = 0;//0
 3be:	90 33       	cpi	r25, 0x30	; 48
 3c0:	19 f4       	brne	.+6      	; 0x3c8 <main+0xae>
 3c2:	10 92 b3 00 	sts	0x00B3, r1
 3c6:	dd cf       	rjmp	.-70     	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 49) LED = 2;//1
 3c8:	91 33       	cpi	r25, 0x31	; 49
 3ca:	19 f4       	brne	.+6      	; 0x3d2 <main+0xb8>
 3cc:	10 93 b3 00 	sts	0x00B3, r17
 3d0:	d8 cf       	rjmp	.-80     	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 50) LED = 4;//2
 3d2:	92 33       	cpi	r25, 0x32	; 50
 3d4:	19 f4       	brne	.+6      	; 0x3dc <main+0xc2>
 3d6:	00 93 b3 00 	sts	0x00B3, r16
 3da:	d3 cf       	rjmp	.-90     	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 51) LED = 8;//3
 3dc:	93 33       	cpi	r25, 0x33	; 51
 3de:	19 f4       	brne	.+6      	; 0x3e6 <main+0xcc>
 3e0:	f0 92 b3 00 	sts	0x00B3, r15
 3e4:	ce cf       	rjmp	.-100    	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 52) LED = 16;//4
 3e6:	94 33       	cpi	r25, 0x34	; 52
 3e8:	19 f4       	brne	.+6      	; 0x3f0 <main+0xd6>
 3ea:	e0 92 b3 00 	sts	0x00B3, r14
 3ee:	c9 cf       	rjmp	.-110    	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 53) LED = 32;//5
 3f0:	95 33       	cpi	r25, 0x35	; 53
 3f2:	19 f4       	brne	.+6      	; 0x3fa <main+0xe0>
 3f4:	d0 92 b3 00 	sts	0x00B3, r13
 3f8:	c4 cf       	rjmp	.-120    	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 54) LED = 64;//6
 3fa:	96 33       	cpi	r25, 0x36	; 54
 3fc:	19 f4       	brne	.+6      	; 0x404 <main+0xea>
 3fe:	c0 92 b3 00 	sts	0x00B3, r12
 402:	bf cf       	rjmp	.-130    	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 55) LED = 128;//7
 404:	97 33       	cpi	r25, 0x37	; 55
 406:	19 f4       	brne	.+6      	; 0x40e <main+0xf4>
 408:	b0 92 b3 00 	sts	0x00B3, r11
 40c:	ba cf       	rjmp	.-140    	; 0x382 <main+0x68>
			if(rf_rx_array[1] == 56) LED = 255;//8
 40e:	98 33       	cpi	r25, 0x38	; 56
 410:	09 f0       	breq	.+2      	; 0x414 <main+0xfa>
 412:	b7 cf       	rjmp	.-146    	; 0x382 <main+0x68>
 414:	a0 92 b3 00 	sts	0x00B3, r10
 418:	b4 cf       	rjmp	.-152    	; 0x382 <main+0x68>

0000041a <uart_getchar>:
}


uint8_t uart_getchar(void)
{
    while( !(UCSR0A & (1<<RXC0)) );
 41a:	80 91 c0 00 	lds	r24, 0x00C0
 41e:	87 ff       	sbrs	r24, 7
 420:	fc cf       	rjmp	.-8      	; 0x41a <uart_getchar>
    return(UDR0);
 422:	80 91 c6 00 	lds	r24, 0x00C6
}
 426:	08 95       	ret

00000428 <delay_ms>:
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 428:	31 e0       	ldi	r19, 0x01	; 1
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 42a:	26 e0       	ldi	r18, 0x06	; 6
 42c:	15 c0       	rjmp	.+42     	; 0x458 <delay_ms+0x30>
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 42e:	37 bb       	out	0x17, r19	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 430:	20 93 b2 00 	sts	0x00B2, r18
	while( (TIFR2 & (1<<TOV2)) == 0);
 434:	b8 9b       	sbis	0x17, 0	; 23
 436:	fe cf       	rjmp	.-4      	; 0x434 <delay_ms+0xc>
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 438:	37 bb       	out	0x17, r19	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 43a:	20 93 b2 00 	sts	0x00B2, r18
	while( (TIFR2 & (1<<TOV2)) == 0);
 43e:	b8 9b       	sbis	0x17, 0	; 23
 440:	fe cf       	rjmp	.-4      	; 0x43e <delay_ms+0x16>
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 442:	37 bb       	out	0x17, r19	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 444:	20 93 b2 00 	sts	0x00B2, r18
	while( (TIFR2 & (1<<TOV2)) == 0);
 448:	b8 9b       	sbis	0x17, 0	; 23
 44a:	fe cf       	rjmp	.-4      	; 0x448 <delay_ms+0x20>
}

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 44c:	37 bb       	out	0x17, r19	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 44e:	20 93 b2 00 	sts	0x00B2, r18
	while( (TIFR2 & (1<<TOV2)) == 0);
 452:	b8 9b       	sbis	0x17, 0	; 23
 454:	fe cf       	rjmp	.-4      	; 0x452 <delay_ms+0x2a>
}

//General short delays
void delay_ms(uint16_t x)
{
	for (; x > 0 ; x--)
 456:	01 97       	sbiw	r24, 0x01	; 1
 458:	00 97       	sbiw	r24, 0x00	; 0
 45a:	49 f7       	brne	.-46     	; 0x42e <delay_ms+0x6>
		delay_us(250);
		delay_us(250);
		delay_us(250);
		delay_us(250);
	}
}
 45c:	08 95       	ret

0000045e <delay_us>:

//General short delays
void delay_us(uint8_t x)
{
	TIFR2 = 0x01; //Clear any interrupt flags on Timer2
 45e:	91 e0       	ldi	r25, 0x01	; 1
 460:	97 bb       	out	0x17, r25	; 23
	TCNT2 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 462:	81 95       	neg	r24
 464:	80 93 b2 00 	sts	0x00B2, r24
	while( (TIFR2 & (1<<TOV2)) == 0);
 468:	b8 9b       	sbis	0x17, 0	; 23
 46a:	fe cf       	rjmp	.-4      	; 0x468 <delay_us+0xa>
}
 46c:	08 95       	ret

0000046e <put_char>:


void put_char(char byte)
{
 46e:	98 2f       	mov	r25, r24
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) );
 470:	80 91 c0 00 	lds	r24, 0x00C0
 474:	85 ff       	sbrs	r24, 5
 476:	fc cf       	rjmp	.-8      	; 0x470 <put_char+0x2>
	/* Put data into buffer, sends the data */
	UDR0 = byte;
 478:	90 93 c6 00 	sts	0x00C6, r25
}
 47c:	08 95       	ret

0000047e <_exit>:
 47e:	f8 94       	cli

00000480 <__stop_program>:
 480:	ff cf       	rjmp	.-2      	; 0x480 <__stop_program>
